//билет 23. регулярные выражение
//существует два синтаксиса для создания регулярного выражения:
//"длинный" синтаксис new RegExp("шаблон", "флаги")
//"короткий" синтаксис (используются "/") /шаблон/ - без флагов, /щаблон/gmi - с флагами gmi 
//i - не зависит от регистра
//g - ищет все совпадения, без него - только первое
//s - точка=\n(перевод строки)
//u - полная поддержка юникода
//y - поиск на конкретной позиции текста 
//метод match(regexp) - для строки возвращает совпадения с рег. выражением regexp, если у этого выражения есть флаг /g, то вернеся массив всех совпадений, если нет - вернет только первое совпадение в виде массива
//метод replace(regexp, replacement) заменяет совпадения с regexp в стоке на replacement (все если есть флаг /g, первое в обратном случае)
//метод test - проверяет есть ли хоть одно совпадение, если да, то вернет true, нет - false
//Символьный класс - спец. обозначения, которое соответсвует любому символу из опред набора.
//Используемые: \d - цифра от 0 до 9, \s - включает в себя символ пробела, табуляции (\t), перевода строки (\n), \w - слово
//!!!регул. выражения могут содержать обычные символы, но и символьные классы тоже. Для каждого сивольного класса существует "обратный класс", которые обозначается той же буквой, но в верхнем регистре. "Обратный" - соответсвует всем другим символам
// . - спец символьный класс, который значит "любой символ, кроме новой строки", также значит "любой символ, но не отсутсвие символа"
//^ $ - якоря, ^ - каретка, совпадение с началом текста, $ - совпадение с концом
//вместе ^...$ часто используются для проверки, совпадает ли строка с шаблоном полностью. Правильный формат ввода данных пол-м
//[]-  означает что ищем любой символ из заданных в скобке, напримере [aoe] - значит, что любой из этих симвовло должен быть, Если значения в скобках указаны через тире, значит, что ищем в промежутке, например [0-5]
//если в начале диапазона стоит картека, например [^aqu] значит, что мы изем любой сивол, кроме этих
// квантификаторы - для указания количества повторений нужных символов. Самый простой - {n} 0 добавляется к символу или сивольному классу и указывает, сколько их нам нужно
//Часть шаблона можно записать как (...) - скобочная группа. Позволяет поместить часть совпадения в отдельный массив
//Альтернация - термин в рег. выражениях, что означает "или". Обозначается как "|". Например gr(a|e)y = gr[ae]y, gra|ey = gra или ey
// Функция проверки email
function checkEmail(email) {
  const regex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
  //^-начало строки
  //[a-zA-Z0-9._-]+ имя пользователя, может содеражать буквы, цифры, точки, подчеркивания, дефисы, @ - обзательнй эл-т, дальше домен.имя, \. - точка перед доменом верхнего уровня [a-zA-Z]{2,4} - домен верхнего уровня - 2-4 буквы, $-конец строки
  return regex.test(email);
}

const emails = [
  "user@example.com","user.name@domain.ru","user@domain","@domain.com","user@.com" 
];//проверяем: 1 - верно, 2 - верно, 3 - неверно(отсутствует .com и тд), 4 - неверно (нету имени пол-ля), 5 - неверно(отсутсвту имя межлу @ и .com)

console.log("Проверка email:");
emails.forEach(email => {
  console.log(`${email} - ${checkEmail(email) ? 'Верный' : 'Неверный'}`);//функция, выводит верная почта или нет
});
// const userEmail = prompt("Введите ваш email:");
if (checkEmail(userEmail)) {
  console.log("Email корректен");
} else {
  console.log("Неверный формат email");//функция для введной нами почтой
}

//билет 24. работа с датой и времненем 
//Date - встроенный объект, который содержит дату и время, а также предоставляет методы управлениями ими
//new Date() - создает объект с временем. Принимает аргументы: year, month, date, hours, minutes, seconds, ms
//year - состоит всегда из 4 цифр
//mont - начинается с 0(январь) по 11(декабрь)
//date - день месяца, если не задан, то принимается значение 1
// если hours, minutes, seconds, ms отсутвуют, то значение принимается равное 0
//getFullYear() - получить год
//getMonth() - получитьь месяц от 0 до 11
//getDate - получить день месяца от 1 до 31
//getHours(), getMinutes(), getSeconds(), getMilliseconds() - получить часы, минуты, сек, мс
//getTime - возвращает кол-во мс, прошедших с 1 января 1970
//Date.parse(str) - считывает дату из строки
const endDate = new Date();
endDate.setDate(endDate.getDate() + 1); // добавляем 1 день к текущей дате

function updateTimer() {
  const now = new Date();
  const diff = endDate - now; // разница в миллисекундах

  if (diff <= 0) {
    console.log("Время вышло!");
    clearInterval(timerInterval);
    return;
  }//если время <0 то время вышло 
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));//переводим мс в дни
  const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)); //в часы 
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));//минуты
  const seconds = Math.floor((diff % (1000 * 60)) / 1000);//секунды

  console.clear();
  console.log(`Осталось: ${days}д ${hours}ч ${minutes}м ${seconds}с`);//выводим переведнные значения 
}

const timerInterval = setInterval(updateTimer, 1000);//запускаем таймер с обновлением
updateTimer();//первое обновление времени таймера 

//билет 25. создание объекта, обращение, перебор свойств объектов
//объект  - тип данных, который хранит в себе информацию в виде пао "клюв-значение". Если массив - нумерованный список, где каждый эл-т имеет свой порядковый номер, то объект 0  список, в котором каждый эл-т сопоставлен со своим ключом и порядок неваэен
//Может быть сосздан с помщью {...} с необязательным списком сво-в. Свойство - пара "ключ:значение", где ключ - строка (имя свойства), а значение мб чем угодно
//У каждого сво-ва есть ключ, инача "имя" или "идентификатор", далее ":" и затем указывается сво-во, если их несколько  - указываем через запятую
//Для удаления сво-ва указываем объект и через точку мя сво-ва и добавляем delete
//Имя сво-ва может состоять из нескольких слов, тогда заключаем его в кавычки. Чтобы обратится к сво-м такого имени, указываем название в квадратных скобках
//если объект объявлене через const то мы можем его изменить
//для перебора сво-в объекта используется for..in
//Объекты хранятся и копируются "по ссылке". То есть переменная хранит не сам объект а его "адрес", другими словами "ссылку" на него. Когда переменная объекта копируется, то копируется ссылка, а сам объект не дублируется

// Условие: Создайте объект book со следующими свойствами: title (название книги) author (автор) year (год издания pages (количество страниц). Напишите функцию getBookInfo(book), которая принимает этот объект и возвращает строку в формате: "Название: [title], Автор: [author], Год: [year]Страниц: [pages]".

const book = {
    title: "JavaScript: The Definitive Guide",
    author: "David Flanagan",
    year: 2020,
    pages: 704,
    getInfo() {
      return `Название: ${this.title}, Автор: ${this.author}, Год: ${this.year}, Страниц: ${this.pages}`;
    }
  };
  
  console.log(book.getInfo());
