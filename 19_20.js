//билет 19. строки. свойства и методя дря работы по строкам 
//строки - любые текстовые данные
//содержимое строки нельзя изменить, для изменения строки нужно создать новую строку и записать ее в ту же самую переменную вместо старой
// свойство lenght - определяет длину строки
//отчет позиций начнается с 0, в методе charArt(pos) в скобках указываем позицию эл-та, который хотим вывести
//можем получить эл-т используя [], отличается от предыдущего тем, что если нет эл-та с такой позицей, то вернет undefined, а charArt - пустую строку
//toLowerCase() - приводит все в нижнему регистру, а toUpperCase() - к верхнему
//indexOf(substr, pos) и lastIndexOf substr - искомая подстрока, а pos - позиция эл-тв с которой начинается поиск, он является необязательным. indexOf - ищет подстроку субстр в строке стр, начиная с позиции пос и возвращает позицию, на которой распалагается совпадание, либо -1 если слвпадения нет
//includes(substr, pos), startWith(substr), endsWith(substr) - методы для поиска по строке без возвращения позиции на которой начинается совпадение. substr - искомая подстрока. возвращает true/false
//substring, substr, slice (start, end), (start, lenght) - методы для получения подстрок из строк
//start - начало искомоц подстроки, end - конец искомой подстроки, lenght - длина искомой подстроки
//метод slice - возвращает часть строки от начала до конца, не включая. Если аргумент end отсутствует, то slice вернет символы до конца строки. Можно задавать отрицательные значение, тогда позиция определена как заданное кол-во символов с конца строки
//substring - возвращает часть строки между старт и енд. Почти тоже самое, что и slice, но мы можем задавать значение start > end. Отрицательные значения (в отличие от метода слайс) он не поддерживает, интерпретируются как 0
//substr - возвращает часть строки от start до lenght. Позволяет указать длину вместо конечной позиции
//padStart() и padEnd() - помогает добавить в начало или конец строки пробел, в сскобках указываем до какой длины должна стать строка
//repeat() - возвращает ноувю строку, которая содержит исходную строку, повторяющуюся несколько раз. В скобкаах указывакм кол-во повторений
//replace() - метод для замены определенного текста в строке. Первый аргумент - текст, который нужно заменить, а второй - текст, которым заменяем
//codePaint(pos) - метод, который возвращает код символа. В скобках указываем позицию этого сивмвола
//String.fromCodePoint(code) - метод, который создает символ по его коду. В скобках указываем код эл-та
const text = "И нет сомнений - интерактивные прототипы освещают чрезвычайно интересные особенности картины в целому";
console.log(`Длина текста: ${text.length} символов`);//длина текста

console.log(`Первый символ: ${text.charAt(0)}`);//выводим первый элемент
console.log(`10-й символ: ${text[9]}`);//выведем 10 символ
console.log(`Последний символ: ${text[text.length - 1]}`);//выводим последний символ
console.log(`Верхний регистр: ${text.toUpperCase()}`);//все к верхнему регистру
console.log(`Нижний регистр: ${text.toLowerCase()}`);//все к нижнему регистру

console.log(`Позиция слова 'особенности': ${text.indexOf('особенности')}`);// выводим позицию слова "особенности"
console.log(`Есть ли слово 'сомнений'? ${text.includes('сомнений')}`); //проверяем есть слово и выведет тру
console.log(`Начинается с 'И'? ${text.startsWith('И')}`); //проверяем начинается ли текст со слова "и" выведет тру
console.log(`Заканчивается на 'лому'? ${text.endsWith('лому')}`); //проверяет заканчивается ли текст на "лому" выведет тру

console.log(`Срез с 18 по 30: ${text.slice(18, 30)}`); //выводим слово по срезу, должен вывести "интерактивные"
console.log(`Подстрока с 31: ${text.substring(31)}`); // должен вывести все начиная со слова "прототипы"

console.log(`Код символа 'И': ${'И'.codePointAt(0)}`); //возвращает код для символа, находящегося на позиции pos:
console.log(`Символ с кодом 1048: ${String.fromCodePoint(1048)}`); //дожен вернуть "и"
console.log('Посимвольный вывод:');
for (const char of text) {
  console.log(char);
}//выводит по символам 

function countChars(str, char) {
  let count = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === char) count++;
  }
  return count;
}//подсчет определенных букв в тексте

console.log(`Количество букв 'ы': ${countChars(text, 'ы')}`);//должен вывести 4

//билет 20. одномерные массивы. добавление, удаление, поиск и замена элементов массива
//массив - особая структура данных, предназначенная для хранения упорядоченных коллекций 
//эл-ты массива нумеруются, начиная с нуля. Получить эл-т массива можно, указав с [] его номер
//метод push -  метод для добавление эл-та в массива, передаем добавляем данные, всегда будут вставать в конец массива 
//unshift - метод для добавления данных в начало массива 
//pop - метод который удаляет послеждний эл-т и возвращает его
//shift - делает тоже самое, но с обартной стороны массива, т.е. вместе удаляния и возвращения последнего эл-та, он прожелывает это с первым 
//splice - универсальный метод для работы с массивами. умеет все, возвращает массива удаленых элементов
//структура slice - (index, deleteCount, elem1,...,elemN),  что означает: начиная с пощиции index удалите deleteCount эл-в и вставь elem1,..,elemN на их место
//Если deleteCount указать равным 0, то метод splice будет вставлять эл-ты  без удаления 
//методы indexOf, lastIndexOf, insludes имеют одинаковый синтаксис и по сути делют одно и тоже, что и эти же методы для строк, но раюботают с эл-ми, а не симва=олами
//indexOf(item, from) - ищет item, начиная с индекса from и возвращает индекс, на котором был искомы эл-Т, если эл-та нет, то вернет 1
//lastIndexOf(item, from) - то же самое, но ищет справа налево
//includes(item, from) - ищет item, начиная с индекса from, но возращает true, если поиск успешен, в обратном случае - false
// Исходный список задач
let tasks = ["Купить молоко", "Сделать уроки", "Позвонить маме"];//массив эл-ов

tasks.push("Записаться к врачу"); //добавим в конец
console.log("После push:", tasks);

tasks.unshift("Утренняя зарядка"); //добавим в начало
console.log("После unshift:", tasks);

const lastTask = tasks.pop(); //удалим последний эл-т
console.log("После pop:", tasks);

const firstTask = tasks.shift();//удалим первы эл-т
console.log("После shift:", tasks);

tasks.splice(1, 0, "Почитать книгу");//добавляем после первого элемента "почитать книгу"
console.log("После splice (добавление):", tasks);

const removed = tasks.splice(0, 1, "Купить хлеб");//заменяем "купить молоко" на "купить хлеб"
console.log("После splice (замена):", tasks);

tasks.splice(2, 1);//удаляем после второго эл-та
console.log("После splice (удаление):", tasks);

console.log("Ищем индекс 'Позвонить маме':", tasks.indexOf("Позвонить маме")); //второй
console.log("Есть ли 'Купить молоко'?", tasks.includes("Купить молоко")); //выведет фолс

console.log("Финальный список задач:", tasks);